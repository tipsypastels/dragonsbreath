const BUILTINS = {
  end({ error }) {
    error(`Do not use the end command in Dragonsbreath. Use significant whitespacing`);
  },

  // TODO this must also add it to any externals
  lock({ children, transpile }) {
    if (children) {
      return [
        'lock',
        transpile(children),
        'release',
      ];
    }

    return 'lock';
  },

  if({ children, transpile, parameters, error, transpileParameter, getExternalName, addExternal, currentScript }) {
    if (parameters.length !== 1) {
      error('The "if" command must take exactly one parameter');
    }

    const condition = parameters[0];

    if (['eq', 'lt', 'gt', 'le', 'ge'].indexOf(condition.type) === -1) {
      error(`The type ${condition.type} cannot be used in a conditional`);
    }

    const compare = `compare ${transpileParameter(condition.left)}, ${transpileParameter(condition.right)}`;

    const externalName = getExternalName(currentScript, 'script');
    addExternal([
      `@ Generated by Dragonsbreath. This is a subscript of ${currentScript}`,
      `${externalName}::`,
      transpile(children),
      'end',
    ]);

    const goto = `goto_if_${condition.type} ${externalName}`;

    return [compare, goto];
  },

  else({ children, transpile }) {
    return transpile(children);
  },

  script({ parameters, error, transpile, children, setCurrentScript }) {
    if (parameters.length !== 1) {
      error(`The "script" command must take exactly one parameter`);
    }

    if (parameters[0].type !== 'token') {
      error(`The parameter to the "script" command must be a token.`)
    }

    setCurrentScript(parameters[0].value);

    return [
      `@ Generated by Dragonsbreath`,
      `${parameters[0].value}::`,
      transpile(children),
      'end',
    ];
  },

  // TODO needs to support clustering say blocks together if they're adjacent
  say({ parameters, error, transpileParameter, getExternalName, addExternal, currentScript }) {
    if (!parameters || !parameters.length) {
      error(`The "say" command must take at least one parameter`)
    }

    const [text, msgbox] = parameters;
    const msgboxOrDefault = msgbox || { 
      type: 'constant', 
      value: 'MSGBOX_DEFAULT' 
    };

    const externalName = getExternalName(currentScript, 'text');
    addExternal([
      `@ Generated by Dragonsbreath. This is a text script of ${currentScript}`,
      `${externalName}:`,
      `.string ${transpileParameter(text)}`
    ]);

    return `msgbox ${externalName}, ${transpileParameter(msgboxOrDefault)}`;
  }
};

module.exports = BUILTINS;